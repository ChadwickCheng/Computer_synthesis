/*
★★★直观理解：加密算法 vs 密钥（为什么说"密钥保密，算法公开"）★★★

【大门和钥匙的比喻】不太准确！正确的比喻是：
    █ 加密算法 就像 【大门的机制设计】（如何设计锁芯、齿轮、卡槽等）
    █ 密钥 就像 【某把特定的钥匙】（具体的数字组合）
    
为什么这个比喻精确？
    ✓ 大门的机制设计公开了 —— 任何人都可以看懂锁怎么工作的
    ✓ 但你的【私人钥匙】必须保密 —— 只有你有！
    ✓ 即使别人知道机制，没有你的钥匙，也打不开你的门
    ✓ 安全性不依赖于"锁的设计是否被人知道"，而依赖于"钥匙只有你有"

【为什么要"公开算法"？】
    1. 算法经过了数学证明和全球安全审查 → 可以信任
    2. 如果算法保密，你无法验证它是否真的安全 → 可能有后门
    3. 就像：医院公开手术方案（让其他医生能评审），不会公开患者隐私（保密）
    4. 开源加密库（OpenSSL）= 算法透明，任何人可以审查代码，==增强安全==
    
【具体例子】
    - AES算法：全球公开的数学算法，任何人都能学、任何语言都能实现
    - 你的密钥：你设定的密码，比如"MyPassword123" 或 256位的随机数
    - 结果：即使我知道AES怎么工作，没有你的密钥，我的数据对我来说没用
    
【为什么不能用"只有你知道的算法"？】
    - 自己设计加密方法 = 自以为安全，其实漏洞百出 ❌
    - "安全性通过保密获得"的系统，一旦暴露则无比脆弱
    - 反例：恩尼格玛机（WWII加密机，算法保密，一暴露就完蛋）
    - 数学证明了的公开算法 > 自己瞎搞的秘密算法

【对称加密的钥匙比喻】
    情景：A寄信给B
    - A和B事先约定：用【同一把钥匙】加密和解密（比如密钥=我们都知道的暗语）
    - A生成钥匙 → 用它加密信件 → B收到后 → 用同一把钥匙解密
    - 缺点：A必须安全地告诉B这把钥匙（有多人时，每两个人都要约定一把钥匙，很麻烦）

【非对称加密的钥匙比喻】
    情景：A寄信给B（B公布了一个"公钥下载链接"）
    - B有【一对钥匙】：
        ✓【公钥】= 公开的，任何人都能下载（就像在邮局公告板上贴了一把钥匙）
        ✓【私钥】= 只有B自己知道（藏在B的保险箱里）
    - A用B公布的【公钥】加密信 → 只有B的【私钥】能解开
    - 好处：A不需要和B事先沟通，直接从网上拿到B的公钥就能发信
    - 这就是互联网能安全工作的原因！

【回答你的关键问题】
    Q：大门和钥匙就是这个意思吗？
    A：差不多，但更精确的是："锁的设计（算法）公开，你的钥匙（密钥）保密"
    
    Q：为什么说"密钥保密，算法公开"？
    A：因为算法的安全性已被数学证明，安全性关键是密钥无人知晓
       如果你的密钥泄露了，再公开的算法也没用
       如果你的算法泄露了，但密钥保密，仍然很安全
    
    Q：那公开算法岂不是给了坏人机会？
    A：不是。就像：医学教科书公开了手术方法，小偷不会因为知道手术方法就能偷器官
       公开算法反而让全球安全研究员去测试它，发现漏洞，修补它 → 更安全

1. 数据加密概念：明文 密钥 加密 密文 解密
2. 对称加密：又称单钥密码或秘密密钥体制，密钥保密，加密解密使用相同密钥；安全性依赖于密钥秘密性而非算法。
    典型算法
        DES：数据加密标准，56位
        3DES：三重DES，112位
        AES、RC2、RC4、RC5：对称
        SM4：中国商用
    n个用户需要 n*(n-1)/2 个密钥
    优：速度快，适合大批量数据
    缺：管理多把钥匙麻烦，容易被破解
3. 非对称加密：私钥保密，公钥可公开；加密和解密使用不同密钥
    典型算法
        RSA：大素数难分解；要1024位以上
    n个用户要n个公钥和n个私钥
    优：适合开放性环境，实现数字签名
    缺：慢
4. 混合密码：
    1. 发送方对数据进行对称加密
    2. 用接收方公钥加密对称密钥
    3. 发送
    4. 接收方私钥解密对称密钥
    5. 对称密钥解密数据
5. 身份认证技术与数字签名：
    1. 哈希函数：将任意长输入转为固定长摘要，不同消息的摘要一定不同，摘要无法还原为原文；雪崩效应：输入微小变化，输出大幅变化
        常见算法：
            MD5：512位数据块输入，128位摘要
            SHA：512位数据块输入，160位摘要
            SM3：国产，512转256
    2. 数字签名：
        实现方式：公共密钥加密方法；
        过程：
            1. 生成公私钥
            2. 数据hash得摘要，私钥加密摘要得签名
            3. 公钥解密签名得摘要
            4. 使用相同hash函数对数据hash得摘要
            5. 比较两个摘要是否相同
        三个功能：报文可鉴别，报文完整，不可否认
    二者结合：阿草(公钥pa，私钥pra) 有珠(公钥pb，私钥prb) 阿草给有珠写情书
        两条线：
            1. 数据线 保证数据保密
                - 情书使用对称密钥k加密，得密文
                - k使用有珠公钥pb加密得到pbk
                - 有珠得到密文和pbk
                - 有珠使用私钥prb解密pbk得到k
                - 有珠使用k解密密文得到情书
                - 将情书使用hash函数得到摘要h1
            2. 签名线 保证是阿草写的，数据没被篡改
                - 阿草使用hash函数对情书得到摘要h2
                - 阿草使用私钥pra加密h2得到签名s
                - 有珠使用阿草公钥pa解密s得到摘要h3
                - 有珠比较h1和h3是否相同
    3. CA证书：保证数字证书的公钥是证书的所有者，防止冒充。
    4. 身份认证技术：
        被鉴别对象本人才知道的信息：口令、验证码
        鉴别对象才具有的信物：IC卡、U盾
        鉴别对象本人具有的生理或行为特征：指纹、虹膜
*/

/*
★关键认识：数字签名保证的是【真实性和完整性】，而非【保密性】
            - 签名采用私钥加密，公钥解密；公钥是公开的，任何人都能解密验证
            - 数据+签名可以公开传输，目的是证明：数据确实来自签名方、数据未被篡改
            - 不能隐藏数据内容；如需保密，应结合对称加密
        常见应用：代码签名、电子合同、SSL证书等

★前端视角：公钥/私钥如何获得？
    1. HTTPS/SSL证书：
        - 网站方持有私钥（保密在服务器），公钥包含在证书中
        - 浏览器访问https时自动获得公钥（在证书里），用来加密数据传给服务器
        - 前端无需主动获取，HTTPS层自动处理
    
    2. 第三方API集成（支付、OAuth登录）：
        - 服务方会通过官方文档/后台给你【公钥】，用来验证签名
        - 例：支付宝、微信支付都会给商户一个公钥，验证回调是否来自正规服务商
        - 前端直接用就行，不涉及私钥
    
    3. JWT Token验证：
        - 后端用私钥签名token，前端拿到token
        - 后端会在某个endpoint（如/.well-known/jwks.json）暴露公钥
        - 前端可以用这个公钥验证token的真实性（不解密内容，只验证签名）
    
    4. npm包/开源代码签名：
        - 包作者用私钥签名，公钥公开在registry或github
        - npm等包管理器自动验证包完整性
        - 前端开发者无感知
    
    总结：实际项目中，【公钥确实会被"发送/暴露"给你】
        - 机制：通过HTTPS通道、文档、公网endpoint、证书等安全方式
        - 这是安全的，因为公钥只能验证，不能伪造签名
        - 私钥永远不会发出去，只在服务方自己的安全环境里使用
*/