/*
1. 数据加密概念：明文 密钥 加密 密文 解密
2. 对称加密：又称单钥密码或秘密密钥体制，密钥保密，加密解密使用相同密钥；安全性依赖于密钥秘密性而非算法。
    典型算法
        DES：数据加密标准，56位
        3DES：三重DES，112位
        AES、RC2、RC4、RC5：对称
        SM4：中国商用
    n个用户需要 n*(n-1)/2 个密钥
    优：速度快，适合大批量数据
    缺：管理多把钥匙麻烦，容易被破解
3. 非对称加密：私钥保密，公钥可公开；加密和解密使用不同密钥
    典型算法
        RSA：大素数难分解；要1024位以上
    n个用户要n个公钥和n个私钥
    优：适合开放性环境，实现数字签名
    缺：慢
4. 混合密码：
    1. 发送方对数据进行对称加密
    2. 用接收方公钥加密对称密钥
    3. 发送
    4. 接收方私钥解密对称密钥
    5. 对称密钥解密数据
5. 身份认证技术与数字签名：
    1. 哈希函数：将任意长输入转为固定长摘要，不同消息的摘要一定不同，摘要无法还原为原文；雪崩效应：输入微小变化，输出大幅变化
        常见算法：
            MD5：512位数据块输入，128位摘要
            SHA：512位数据块输入，160位摘要
            SM3：国产，512转256
    2. 数字签名：
        实现方式：公共密钥加密方法；
        过程：
            1. 生成公私钥
            2. 数据hash得摘要，私钥加密摘要得签名
            3. 公钥解密签名得摘要
            4. 使用相同hash函数对数据hash得摘要
            5. 比较两个摘要是否相同
        三个功能：报文可鉴别，报文完整，不可否认
    二者结合：阿草(公钥pa，私钥pra) 有珠(公钥pb，私钥prb) 阿草给有珠写情书
        两条线：
            1. 数据线 保证数据保密
                - 情书使用对称密钥k加密，得密文
                - k使用有珠公钥pb加密得到pbk
                - 有珠得到密文和pbk
                - 有珠使用私钥prb解密pbk得到k
                - 有珠使用k解密密文得到情书
                - 将情书使用hash函数得到摘要h1
            2. 签名线 保证是阿草写的，数据没被篡改
                - 阿草使用hash函数对情书得到摘要h2
                - 阿草使用私钥pra加密h2得到签名s
                - 有珠使用阿草公钥pa解密s得到摘要h3
                - 有珠比较h1和h3是否相同
*/

/*
★关键认识：数字签名保证的是【真实性和完整性】，而非【保密性】
            - 签名采用私钥加密，公钥解密；公钥是公开的，任何人都能解密验证
            - 数据+签名可以公开传输，目的是证明：数据确实来自签名方、数据未被篡改
            - 不能隐藏数据内容；如需保密，应结合对称加密
        常见应用：代码签名、电子合同、SSL证书等

★前端视角：公钥/私钥如何获得？
    1. HTTPS/SSL证书：
        - 网站方持有私钥（保密在服务器），公钥包含在证书中
        - 浏览器访问https时自动获得公钥（在证书里），用来加密数据传给服务器
        - 前端无需主动获取，HTTPS层自动处理
    
    2. 第三方API集成（支付、OAuth登录）：
        - 服务方会通过官方文档/后台给你【公钥】，用来验证签名
        - 例：支付宝、微信支付都会给商户一个公钥，验证回调是否来自正规服务商
        - 前端直接用就行，不涉及私钥
    
    3. JWT Token验证：
        - 后端用私钥签名token，前端拿到token
        - 后端会在某个endpoint（如/.well-known/jwks.json）暴露公钥
        - 前端可以用这个公钥验证token的真实性（不解密内容，只验证签名）
    
    4. npm包/开源代码签名：
        - 包作者用私钥签名，公钥公开在registry或github
        - npm等包管理器自动验证包完整性
        - 前端开发者无感知
    
    总结：实际项目中，【公钥确实会被"发送/暴露"给你】
        - 机制：通过HTTPS通道、文档、公网endpoint、证书等安全方式
        - 这是安全的，因为公钥只能验证，不能伪造签名
        - 私钥永远不会发出去，只在服务方自己的安全环境里使用
*/